# HackX 去中心化黑客松平台 - 数据库设计文档

## 文档概述

本文档详细描述了HackX平台的数据库设计，包括表结构、关系设计、索引策略、以及与Web3和IPFS的混合存储架构。作为去中心化平台，我们采用PostgreSQL作为缓存和辅助存储，核心数据存储在区块链和IPFS上。

## 设计原则

### 1. 混合存储架构
- **区块链存储**: 核心状态、关键ID、IPFS哈希
- **IPFS存储**: 详细元数据、文件内容、用户资料
- **PostgreSQL**: 缓存、索引、查询优化、辅助功能

### 2. 数据一致性策略
- **最终一致性**: 接受区块链确认延迟
- **双写策略**: 数据同时写入链上和数据库
- **同步机制**: 定期从链上同步数据
- **冲突解决**: 以链上数据为准

### 3. 性能优化原则
- **读写分离**: 读取优先使用缓存
- **索引优化**: 针对查询模式设计索引
- **分页查询**: 避免大量数据传输
- **缓存策略**: Redis缓存热点数据

## 数据库架构图

```
┌─────────────────────────────────────────────────────────────┐
│                    HackX 混合存储架构                        │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────────────┐    ┌─────────────────┐    ┌──────────┐│
│  │   PostgreSQL    │    │   区块链        │    │   IPFS   ││
│  │   (缓存/索引)    │    │   (核心状态)    │    │  (元数据) ││
│  │                 │    │                 │    │          ││
│  │ • 用户索引      │◄──►│ • 用户注册      │◄──►│ • 用户资料││
│  │ • 搜索缓存      │    │ • 黑客松创建    │    │ • 项目文件││
│  │ • 统计数据      │    │ • 项目提交      │    │ • 活动详情││
│  │ • 关系映射      │    │ • 评分记录      │    │ • 评审反馈││
│  │ • 辅助功能      │    │ • 权限验证      │    │ • NFT元数据││
│  └─────────────────┘    └─────────────────┘    └──────────┘│
│                                                             │
│  ┌─────────────────────────────────────────────────────────┐│
│  │                     同步机制                            ││
│  │                                                         ││
│  │  链上事件监听 → 数据解析 → 数据库更新 → 缓存刷新        ││
│  │  定期同步检查 → 数据对比 → 差异修复 → 一致性验证        ││
│  └─────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────┘
```

## 核心表结构设计

### 1. 用户管理表

#### users (用户基础信息表)
```sql
CREATE TABLE users (
    -- 主键与基础信息
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email VARCHAR(255) UNIQUE,
    username VARCHAR(50) UNIQUE,
    avatar_url TEXT,
    bio TEXT,
    
    -- Web3相关字段
    wallet_address VARCHAR(42) UNIQUE, -- 以太坊地址
    ipfs_profile_hash TEXT,           -- IPFS上的用户资料哈希
    chain_id INTEGER DEFAULT 1,       -- 所在区块链网络
    
    -- 缓存字段 (从链上同步)
    contract_user_id BIGINT,          -- 智能合约中的用户ID
    last_tx_hash VARCHAR(66),         -- 最后一次交易哈希
    last_block_number BIGINT,         -- 最后一次更新的区块号
    last_gas_used INTEGER,            -- 最后一次交易消耗的Gas
    profile_sync_status VARCHAR(20) DEFAULT 'pending', -- 同步状态
    
    -- 系统字段
    reputation_score INTEGER DEFAULT 0,
    email_verified BOOLEAN DEFAULT FALSE,
    wallet_verified BOOLEAN DEFAULT FALSE,
    is_active BOOLEAN DEFAULT TRUE,
    privacy_settings JSONB DEFAULT '{}',
    notification_settings JSONB DEFAULT '{}',
    
    -- 时间戳
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    last_login_at TIMESTAMP,
    
    -- 约束
    CONSTRAINT valid_wallet_address CHECK (
        wallet_address IS NULL OR 
        wallet_address ~ '^0x[a-fA-F0-9]{40}$'
    ),
    CONSTRAINT valid_email CHECK (
        email IS NULL OR 
        email ~ '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$'
    )
);

-- 索引
CREATE INDEX idx_users_wallet_address ON users(wallet_address);
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_username ON users(username);
CREATE INDEX idx_users_chain_id ON users(chain_id);
CREATE INDEX idx_users_contract_id ON users(contract_user_id);
CREATE INDEX idx_users_reputation ON users(reputation_score DESC);
CREATE INDEX idx_users_active ON users(is_active) WHERE is_active = true;

-- 触发器：自动更新时间戳
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_users_updated_at 
    BEFORE UPDATE ON users 
    FOR EACH ROW 
    EXECUTE FUNCTION update_updated_at_column();
```

#### user_skills (用户技能标签表)
```sql
CREATE TABLE user_skills (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    name VARCHAR(100) NOT NULL,
    level VARCHAR(20) DEFAULT 'intermediate' CHECK (
        level IN ('beginner', 'intermediate', 'advanced', 'expert')
    ),
    category VARCHAR(50) DEFAULT 'programming' CHECK (
        category IN ('programming', 'design', 'business', 'blockchain', 'other')
    ),
    
    -- Web3验证
    blockchain_verified BOOLEAN DEFAULT FALSE,
    verification_tx_hash VARCHAR(66),
    
    created_at TIMESTAMP DEFAULT NOW(),
    
    -- 唯一约束
    UNIQUE(user_id, name)
);

CREATE INDEX idx_user_skills_user_id ON user_skills(user_id);
CREATE INDEX idx_user_skills_category ON user_skills(category);
CREATE INDEX idx_user_skills_level ON user_skills(level);
CREATE INDEX idx_user_skills_verified ON user_skills(blockchain_verified);
```

#### user_social_links (用户社交链接表)
```sql
CREATE TABLE user_social_links (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    platform VARCHAR(50) NOT NULL CHECK (
        platform IN ('github', 'twitter', 'linkedin', 'discord', 'telegram', 'website')
    ),
    url TEXT NOT NULL,
    verified BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT NOW(),
    
    UNIQUE(user_id, platform)
);

CREATE INDEX idx_user_social_links_user_id ON user_social_links(user_id);
CREATE INDEX idx_user_social_links_platform ON user_social_links(platform);
```

### 2. 黑客松管理表

#### hackathons (黑客松主表)
```sql
CREATE TABLE hackathons (
    -- 主键与基础信息
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    title VARCHAR(255) NOT NULL,
    description TEXT,
    
    -- 时间信息
    start_date TIMESTAMP NOT NULL,
    end_date TIMESTAMP NOT NULL,
    registration_deadline TIMESTAMP,
    
    -- 状态管理
    status VARCHAR(20) DEFAULT 'draft' CHECK (
        status IN ('draft', 'upcoming', 'ongoing', 'ended', 'cancelled')
    ),
    
    -- 组织者信息
    organizer_id UUID REFERENCES users(id),
    organizer_address VARCHAR(42), -- 区块链地址
    
    -- Web3相关字段
    contract_id BIGINT UNIQUE,              -- 智能合约中的黑客松ID
    ipfs_hash TEXT,                         -- IPFS上的详细数据哈希
    tx_hash VARCHAR(66),                    -- 创建交易哈希
    block_number BIGINT,                    -- 创建时的区块号
    gas_used INTEGER,                       -- 创建时消耗的Gas
    sync_status VARCHAR(20) DEFAULT 'pending', -- 同步状态
    
    -- 扩展数据 (JSONB格式存储)
    prizes JSONB DEFAULT '[]',              -- 奖项信息
    tracks JSONB DEFAULT '[]',              -- 赛道信息
    judges JSONB DEFAULT '[]',              -- 评委信息
    sponsors JSONB DEFAULT '[]',            -- 赞助商信息
    requirements JSONB DEFAULT '[]',        -- 参与要求
    metadata JSONB DEFAULT '{}',            -- 其他元数据
    
    -- 统计字段 (缓存)
    participant_count INTEGER DEFAULT 0,
    project_count INTEGER DEFAULT 0,
    total_prize_pool DECIMAL(20, 8) DEFAULT 0,
    
    -- 设置
    is_featured BOOLEAN DEFAULT FALSE,
    is_public BOOLEAN DEFAULT TRUE,
    max_participants INTEGER,
    
    -- 时间戳
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    
    -- 约束
    CONSTRAINT valid_dates CHECK (start_date < end_date),
    CONSTRAINT valid_registration_deadline CHECK (
        registration_deadline IS NULL OR registration_deadline <= start_date
    )
);

-- 索引
CREATE INDEX idx_hackathons_contract_id ON hackathons(contract_id);
CREATE INDEX idx_hackathons_organizer_id ON hackathons(organizer_id);
CREATE INDEX idx_hackathons_status ON hackathons(status);
CREATE INDEX idx_hackathons_start_date ON hackathons(start_date);
CREATE INDEX idx_hackathons_end_date ON hackathons(end_date);
CREATE INDEX idx_hackathons_featured ON hackathons(is_featured) WHERE is_featured = true;
CREATE INDEX idx_hackathons_public ON hackathons(is_public) WHERE is_public = true;
CREATE INDEX idx_hackathons_sync_status ON hackathons(sync_status);

-- 全文搜索索引
CREATE INDEX idx_hackathons_search ON hackathons USING gin(
    to_tsvector('english', title || ' ' || COALESCE(description, ''))
);

-- 触发器
CREATE TRIGGER update_hackathons_updated_at 
    BEFORE UPDATE ON hackathons 
    FOR EACH ROW 
    EXECUTE FUNCTION update_updated_at_column();
```

#### hackathon_participants (黑客松参与者表)
```sql
CREATE TABLE hackathon_participants (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    hackathon_id UUID NOT NULL REFERENCES hackathons(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    
    -- 参与信息
    role VARCHAR(20) DEFAULT 'participant' CHECK (
        role IN ('participant', 'judge', 'mentor', 'sponsor')
    ),
    status VARCHAR(20) DEFAULT 'registered' CHECK (
        status IN ('registered', 'checked_in', 'submitted', 'withdrawn')
    ),
    
    -- Web3相关
    registration_tx_hash VARCHAR(66),      -- 注册交易哈希
    registration_block_number BIGINT,     -- 注册区块号
    
    -- 时间戳
    registered_at TIMESTAMP DEFAULT NOW(),
    checked_in_at TIMESTAMP,
    submitted_at TIMESTAMP,
    
    -- 唯一约束
    UNIQUE(hackathon_id, user_id)
);

CREATE INDEX idx_hackathon_participants_hackathon_id ON hackathon_participants(hackathon_id);
CREATE INDEX idx_hackathon_participants_user_id ON hackathon_participants(user_id);
CREATE INDEX idx_hackathon_participants_role ON hackathon_participants(role);
CREATE INDEX idx_hackathon_participants_status ON hackathon_participants(status);
```

### 3. 项目管理表

#### projects (项目主表)
```sql
CREATE TABLE projects (
    -- 主键与基础信息
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    
    -- 关联关系
    hackathon_id UUID REFERENCES hackathons(id) ON DELETE CASCADE,
    team_id UUID REFERENCES teams(id),
    
    -- 项目信息
    track VARCHAR(100),                    -- 参赛赛道
    github_url TEXT,
    demo_url TEXT,
    video_url TEXT,
    presentation_url TEXT,
    
    -- Web3相关字段
    contract_id BIGINT UNIQUE,             -- 智能合约中的项目ID
    ipfs_hash TEXT,                        -- IPFS上的项目文件哈希
    tx_hash VARCHAR(66),                   -- 提交交易哈希
    block_number BIGINT,                   -- 提交时的区块号
    gas_used INTEGER,                      -- 提交时消耗的Gas
    sync_status VARCHAR(20) DEFAULT 'pending', -- 同步状态
    
    -- 状态管理
    status VARCHAR(20) DEFAULT 'draft' CHECK (
        status IN ('draft', 'submitted', 'under_review', 'reviewed', 'winner', 'disqualified')
    ),
    
    -- 扩展数据
    tags JSONB DEFAULT '[]',               -- 项目标签
    technologies JSONB DEFAULT '[]',       -- 使用的技术
    team_members JSONB DEFAULT '[]',       -- 团队成员信息
    
    -- 评分相关 (缓存)
    average_score DECIMAL(3, 2) DEFAULT 0,
    total_scores INTEGER DEFAULT 0,
    like_count INTEGER DEFAULT 0,
    view_count INTEGER DEFAULT 0,
    
    -- NFT证书
    nft_certificate_address VARCHAR(42),   -- NFT证书合约地址
    nft_token_id BIGINT,                   -- NFT Token ID
    
    -- 时间戳
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    submitted_at TIMESTAMP,
    
    -- 约束
    CONSTRAINT valid_score CHECK (average_score >= 0 AND average_score <= 5)
);

-- 索引
CREATE INDEX idx_projects_contract_id ON projects(contract_id);
CREATE INDEX idx_projects_hackathon_id ON projects(hackathon_id);
CREATE INDEX idx_projects_team_id ON projects(team_id);
CREATE INDEX idx_projects_status ON projects(status);
CREATE INDEX idx_projects_track ON projects(track);
CREATE INDEX idx_projects_average_score ON projects(average_score DESC);
CREATE INDEX idx_projects_like_count ON projects(like_count DESC);
CREATE INDEX idx_projects_submitted_at ON projects(submitted_at);
CREATE INDEX idx_projects_sync_status ON projects(sync_status);

-- 全文搜索索引
CREATE INDEX idx_projects_search ON projects USING gin(
    to_tsvector('english', name || ' ' || COALESCE(description, ''))
);

-- 触发器
CREATE TRIGGER update_projects_updated_at 
    BEFORE UPDATE ON projects 
    FOR EACH ROW 
    EXECUTE FUNCTION update_updated_at_column();
```

#### project_scores (项目评分表)
```sql
CREATE TABLE project_scores (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    project_id UUID NOT NULL REFERENCES projects(id) ON DELETE CASCADE,
    judge_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    
    -- 评分信息
    technical_score INTEGER CHECK (technical_score >= 1 AND technical_score <= 5),
    innovation_score INTEGER CHECK (innovation_score >= 1 AND innovation_score <= 5),
    design_score INTEGER CHECK (design_score >= 1 AND design_score <= 5),
    business_score INTEGER CHECK (business_score >= 1 AND business_score <= 5),
    overall_score DECIMAL(3, 2) CHECK (overall_score >= 1 AND overall_score <= 5),
    
    -- 评审反馈
    feedback TEXT,
    strengths TEXT,
    improvements TEXT,
    
    -- Web3相关
    tx_hash VARCHAR(66),                   -- 评分交易哈希
    block_number BIGINT,                   -- 评分区块号
    gas_used INTEGER,                      -- 消耗的Gas
    sync_status VARCHAR(20) DEFAULT 'pending', -- 同步状态
    
    -- 状态
    is_final BOOLEAN DEFAULT FALSE,       -- 是否为最终评分
    
    -- 时间戳
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    
    -- 唯一约束
    UNIQUE(project_id, judge_id)
);

CREATE INDEX idx_project_scores_project_id ON project_scores(project_id);
CREATE INDEX idx_project_scores_judge_id ON project_scores(judge_id);
CREATE INDEX idx_project_scores_overall_score ON project_scores(overall_score DESC);
CREATE INDEX idx_project_scores_is_final ON project_scores(is_final);
CREATE INDEX idx_project_scores_sync_status ON project_scores(sync_status);

-- 触发器：自动计算项目平均分
CREATE OR REPLACE FUNCTION update_project_average_score()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE projects 
    SET 
        average_score = (
            SELECT AVG(overall_score) 
            FROM project_scores 
            WHERE project_id = COALESCE(NEW.project_id, OLD.project_id)
            AND is_final = true
        ),
        total_scores = (
            SELECT COUNT(*) 
            FROM project_scores 
            WHERE project_id = COALESCE(NEW.project_id, OLD.project_id)
            AND is_final = true
        )
    WHERE id = COALESCE(NEW.project_id, OLD.project_id);
    
    RETURN COALESCE(NEW, OLD);
END;
$$ language 'plpgsql';

CREATE TRIGGER update_project_average_score_trigger
    AFTER INSERT OR UPDATE OR DELETE ON project_scores
    FOR EACH ROW
    EXECUTE FUNCTION update_project_average_score();
```

#### project_likes (项目点赞表)
```sql
CREATE TABLE project_likes (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    project_id UUID NOT NULL REFERENCES projects(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    
    -- Web3相关
    tx_hash VARCHAR(66),                   -- 点赞交易哈希 (可选)
    sync_status VARCHAR(20) DEFAULT 'local', -- 同步状态
    
    created_at TIMESTAMP DEFAULT NOW(),
    
    -- 唯一约束
    UNIQUE(project_id, user_id)
);

CREATE INDEX idx_project_likes_project_id ON project_likes(project_id);
CREATE INDEX idx_project_likes_user_id ON project_likes(user_id);

-- 触发器：自动更新项目点赞数
CREATE OR REPLACE FUNCTION update_project_like_count()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE projects 
    SET like_count = (
        SELECT COUNT(*) 
        FROM project_likes 
        WHERE project_id = COALESCE(NEW.project_id, OLD.project_id)
    )
    WHERE id = COALESCE(NEW.project_id, OLD.project_id);
    
    RETURN COALESCE(NEW, OLD);
END;
$$ language 'plpgsql';

CREATE TRIGGER update_project_like_count_trigger
    AFTER INSERT OR DELETE ON project_likes
    FOR EACH ROW
    EXECUTE FUNCTION update_project_like_count();
```

### 4. 团队管理表

#### teams (团队表)
```sql
CREATE TABLE teams (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    
    -- 团队信息
    leader_id UUID NOT NULL REFERENCES users(id),
    hackathon_id UUID REFERENCES hackathons(id) ON DELETE CASCADE,
    
    -- 设置
    max_members INTEGER DEFAULT 5,
    is_open BOOLEAN DEFAULT TRUE,          -- 是否开放加入
    invite_code VARCHAR(50) UNIQUE,        -- 邀请码
    
    -- Web3相关
    wallet_addresses JSONB DEFAULT '[]',   -- 团队成员钱包地址
    
    -- 统计
    member_count INTEGER DEFAULT 1,
    
    -- 时间戳
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_teams_leader_id ON teams(leader_id);
CREATE INDEX idx_teams_hackathon_id ON teams(hackathon_id);
CREATE INDEX idx_teams_invite_code ON teams(invite_code);
CREATE INDEX idx_teams_is_open ON teams(is_open) WHERE is_open = true;

CREATE TRIGGER update_teams_updated_at 
    BEFORE UPDATE ON teams 
    FOR EACH ROW 
    EXECUTE FUNCTION update_updated_at_column();
```

#### team_members (团队成员表)
```sql
CREATE TABLE team_members (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    team_id UUID NOT NULL REFERENCES teams(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    
    -- 成员信息
    role VARCHAR(50) DEFAULT 'member' CHECK (
        role IN ('leader', 'member', 'pending', 'invited')
    ),
    status VARCHAR(20) DEFAULT 'active' CHECK (
        status IN ('active', 'inactive', 'removed')
    ),
    
    -- 贡献信息
    contribution TEXT,
    skills JSONB DEFAULT '[]',
    
    -- 时间戳
    joined_at TIMESTAMP DEFAULT NOW(),
    left_at TIMESTAMP,
    
    -- 唯一约束
    UNIQUE(team_id, user_id)
);

CREATE INDEX idx_team_members_team_id ON team_members(team_id);
CREATE INDEX idx_team_members_user_id ON team_members(user_id);
CREATE INDEX idx_team_members_role ON team_members(role);
CREATE INDEX idx_team_members_status ON team_members(status);

-- 触发器：自动更新团队成员数
CREATE OR REPLACE FUNCTION update_team_member_count()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE teams 
    SET member_count = (
        SELECT COUNT(*) 
        FROM team_members 
        WHERE team_id = COALESCE(NEW.team_id, OLD.team_id)
        AND status = 'active'
    )
    WHERE id = COALESCE(NEW.team_id, OLD.team_id);
    
    RETURN COALESCE(NEW, OLD);
END;
$$ language 'plpgsql';

CREATE TRIGGER update_team_member_count_trigger
    AFTER INSERT OR UPDATE OR DELETE ON team_members
    FOR EACH ROW
    EXECUTE FUNCTION update_team_member_count();
```

### 5. Web3功能表

#### dao_proposals (DAO提案表)
```sql
CREATE TABLE dao_proposals (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    
    -- 提案基础信息
    title VARCHAR(255) NOT NULL,
    description TEXT NOT NULL,
    proposer_id UUID REFERENCES users(id),
    proposer_address VARCHAR(42) NOT NULL,
    
    -- 提案类型和内容
    proposal_type VARCHAR(50) NOT NULL CHECK (
        proposal_type IN ('governance', 'funding', 'technical', 'partnership', 'other')
    ),
    target_contract VARCHAR(42),           -- 目标合约地址
    calldata TEXT,                         -- 调用数据
    
    -- Web3相关
    contract_proposal_id BIGINT UNIQUE,    -- 智能合约中的提案ID
    tx_hash VARCHAR(66),                   -- 创建交易哈希
    block_number BIGINT,                   -- 创建区块号
    
    -- 投票统计 (缓存)
    for_votes BIGINT DEFAULT 0,
    against_votes BIGINT DEFAULT 0,
    abstain_votes BIGINT DEFAULT 0,
    total_votes BIGINT DEFAULT 0,
    
    -- 状态管理
    status VARCHAR(20) DEFAULT 'active' CHECK (
        status IN ('pending', 'active', 'succeeded', 'defeated', 'executed', 'cancelled')
    ),
    
    -- 时间信息
    voting_start_time TIMESTAMP,
    voting_end_time TIMESTAMP,
    execution_time TIMESTAMP,
    
    -- 执行信息
    executed BOOLEAN DEFAULT FALSE,
    execution_tx_hash VARCHAR(66),
    execution_block_number BIGINT,
    
    -- 时间戳
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_dao_proposals_contract_id ON dao_proposals(contract_proposal_id);
CREATE INDEX idx_dao_proposals_proposer_id ON dao_proposals(proposer_id);
CREATE INDEX idx_dao_proposals_proposer_address ON dao_proposals(proposer_address);
CREATE INDEX idx_dao_proposals_status ON dao_proposals(status);
CREATE INDEX idx_dao_proposals_proposal_type ON dao_proposals(proposal_type);
CREATE INDEX idx_dao_proposals_voting_end_time ON dao_proposals(voting_end_time);
CREATE INDEX idx_dao_proposals_executed ON dao_proposals(executed);

CREATE TRIGGER update_dao_proposals_updated_at 
    BEFORE UPDATE ON dao_proposals 
    FOR EACH ROW 
    EXECUTE FUNCTION update_updated_at_column();
```

#### dao_votes (DAO投票记录表)
```sql
CREATE TABLE dao_votes (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    proposal_id UUID NOT NULL REFERENCES dao_proposals(id) ON DELETE CASCADE,
    voter_id UUID REFERENCES users(id),
    voter_address VARCHAR(42) NOT NULL,
    
    -- 投票信息
    support INTEGER NOT NULL CHECK (support IN (0, 1, 2)), -- 0: against, 1: for, 2: abstain
    voting_power BIGINT NOT NULL,          -- 投票权重
    reason TEXT,                           -- 投票理由
    
    -- Web3相关
    tx_hash VARCHAR(66) NOT NULL,          -- 投票交易哈希
    block_number BIGINT NOT NULL,          -- 投票区块号
    gas_used INTEGER,                      -- 消耗的Gas
    
    -- 时间戳
    voted_at TIMESTAMP DEFAULT NOW(),
    
    -- 唯一约束
    UNIQUE(proposal_id, voter_address)
);

CREATE INDEX idx_dao_votes_proposal_id ON dao_votes(proposal_id);
CREATE INDEX idx_dao_votes_voter_id ON dao_votes(voter_id);
CREATE INDEX idx_dao_votes_voter_address ON dao_votes(voter_address);
CREATE INDEX idx_dao_votes_support ON dao_votes(support);
CREATE INDEX idx_dao_votes_tx_hash ON dao_votes(tx_hash);

-- 触发器：自动更新提案投票统计
CREATE OR REPLACE FUNCTION update_proposal_vote_count()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE dao_proposals 
    SET 
        for_votes = (
            SELECT COALESCE(SUM(voting_power), 0) 
            FROM dao_votes 
            WHERE proposal_id = COALESCE(NEW.proposal_id, OLD.proposal_id) 
            AND support = 1
        ),
        against_votes = (
            SELECT COALESCE(SUM(voting_power), 0) 
            FROM dao_votes 
            WHERE proposal_id = COALESCE(NEW.proposal_id, OLD.proposal_id) 
            AND support = 0
        ),
        abstain_votes = (
            SELECT COALESCE(SUM(voting_power), 0) 
            FROM dao_votes 
            WHERE proposal_id = COALESCE(NEW.proposal_id, OLD.proposal_id) 
            AND support = 2
        ),
        total_votes = (
            SELECT COUNT(*) 
            FROM dao_votes 
            WHERE proposal_id = COALESCE(NEW.proposal_id, OLD.proposal_id)
        )
    WHERE id = COALESCE(NEW.proposal_id, OLD.proposal_id);
    
    RETURN COALESCE(NEW, OLD);
END;
$$ language 'plpgsql';

CREATE TRIGGER update_proposal_vote_count_trigger
    AFTER INSERT OR UPDATE OR DELETE ON dao_votes
    FOR EACH ROW
    EXECUTE FUNCTION update_proposal_vote_count();
```

#### nft_certificates (NFT证书表)
```sql
CREATE TABLE nft_certificates (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    
    -- NFT基础信息
    token_id VARCHAR(255) NOT NULL,
    contract_address VARCHAR(42) NOT NULL,
    owner_address VARCHAR(42) NOT NULL,
    
    -- 证书信息
    certificate_type VARCHAR(50) NOT NULL CHECK (
        certificate_type IN ('participation', 'achievement', 'winner', 'judge', 'sponsor', 'mentor')
    ),
    title VARCHAR(255) NOT NULL,
    description TEXT,
    
    -- 关联信息
    user_id UUID REFERENCES users(id),
    hackathon_id UUID REFERENCES hackathons(id),
    project_id UUID REFERENCES projects(id),
    
    -- IPFS元数据
    metadata_ipfs_hash TEXT,              -- 元数据IPFS哈希
    image_ipfs_hash TEXT,                 -- 图片IPFS哈希
    
    -- 区块链信息
    mint_tx_hash VARCHAR(66) NOT NULL,    -- 铸造交易哈希
    mint_block_number BIGINT NOT NULL,    -- 铸造区块号
    mint_gas_used INTEGER,                -- 铸造消耗的Gas
    
    -- 转移信息
    transfer_count INTEGER DEFAULT 0,
    last_transfer_tx_hash VARCHAR(66),
    last_transfer_block_number BIGINT,
    transferred_at TIMESTAMP,
    
    -- 属性
    rarity VARCHAR(20) DEFAULT 'common' CHECK (
        rarity IN ('common', 'uncommon', 'rare', 'epic', 'legendary')
    ),
    attributes JSONB DEFAULT '{}',        -- NFT属性
    
    -- 时间戳
    minted_at TIMESTAMP DEFAULT NOW(),
    
    -- 唯一约束
    UNIQUE(contract_address, token_id)
);

CREATE INDEX idx_nft_certificates_token_id ON nft_certificates(token_id);
CREATE INDEX idx_nft_certificates_contract_address ON nft_certificates(contract_address);
CREATE INDEX idx_nft_certificates_owner_address ON nft_certificates(owner_address);
CREATE INDEX idx_nft_certificates_user_id ON nft_certificates(user_id);
CREATE INDEX idx_nft_certificates_hackathon_id ON nft_certificates(hackathon_id);
CREATE INDEX idx_nft_certificates_project_id ON nft_certificates(project_id);
CREATE INDEX idx_nft_certificates_certificate_type ON nft_certificates(certificate_type);
CREATE INDEX idx_nft_certificates_rarity ON nft_certificates(rarity);
CREATE INDEX idx_nft_certificates_mint_tx_hash ON nft_certificates(mint_tx_hash);
```

#### staking_records (质押记录表)
```sql
CREATE TABLE staking_records (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    
    -- 质押者信息
    user_id UUID REFERENCES users(id),
    user_address VARCHAR(42) NOT NULL,
    
    -- 质押信息
    amount DECIMAL(20, 8) NOT NULL CHECK (amount > 0),
    staking_type VARCHAR(50) NOT NULL CHECK (
        staking_type IN ('governance', 'liquidity', 'validator', 'hackathon_bond')
    ),
    
    -- 时间信息
    start_time TIMESTAMP NOT NULL,
    end_time TIMESTAMP,                    -- NULL表示无固定期限
    lock_duration INTEGER,                 -- 锁定天数
    
    -- 奖励信息
    apy_rate DECIMAL(5, 2),               -- 年化收益率
    rewards_earned DECIMAL(20, 8) DEFAULT 0,
    rewards_claimed DECIMAL(20, 8) DEFAULT 0,
    last_reward_claim_time TIMESTAMP,
    
    -- 状态管理
    status VARCHAR(20) DEFAULT 'active' CHECK (
        status IN ('active', 'unstaking', 'completed', 'slashed')
    ),
    
    -- 区块链信息
    stake_tx_hash VARCHAR(66) NOT NULL,   -- 质押交易哈希
    stake_block_number BIGINT NOT NULL,   -- 质押区块号
    unstake_tx_hash VARCHAR(66),          -- 取消质押交易哈希
    unstake_block_number BIGINT,          -- 取消质押区块号
    
    -- 惩罚信息
    slashed_amount DECIMAL(20, 8) DEFAULT 0,
    slash_reason TEXT,
    slash_tx_hash VARCHAR(66),
    
    -- 时间戳
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_staking_records_user_id ON staking_records(user_id);
CREATE INDEX idx_staking_records_user_address ON staking_records(user_address);
CREATE INDEX idx_staking_records_staking_type ON staking_records(staking_type);
CREATE INDEX idx_staking_records_status ON staking_records(status);
CREATE INDEX idx_staking_records_start_time ON staking_records(start_time);
CREATE INDEX idx_staking_records_end_time ON staking_records(end_time);
CREATE INDEX idx_staking_records_stake_tx_hash ON staking_records(stake_tx_hash);

CREATE TRIGGER update_staking_records_updated_at 
    BEFORE UPDATE ON staking_records 
    FOR EACH ROW 
    EXECUTE FUNCTION update_updated_at_column();
```

### 6. 系统辅助表

#### notifications (通知表)
```sql
CREATE TABLE notifications (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    
    -- 接收者信息
    recipient_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    recipient_address VARCHAR(42),
    
    -- 通知内容
    type VARCHAR(50) NOT NULL CHECK (
        type IN ('hackathon_start', 'hackathon_end', 'project_submitted', 'score_received', 
                'team_invitation', 'dao_proposal', 'nft_received', 'staking_reward', 'system_update')
    ),
    title VARCHAR(255) NOT NULL,
    message TEXT NOT NULL,
    
    -- 关联信息
    hackathon_id UUID REFERENCES hackathons(id),
    project_id UUID REFERENCES projects(id),
    proposal_id UUID REFERENCES dao_proposals(id),
    
    -- 通知数据
    data JSONB DEFAULT '{}',              -- 额外数据
    action_url TEXT,                      -- 操作链接
    
    -- 状态
    is_read BOOLEAN DEFAULT FALSE,
    is_sent BOOLEAN DEFAULT FALSE,        -- 是否已发送 (邮件/推送)
    delivery_method VARCHAR(20) DEFAULT 'in_app' CHECK (
        delivery_method IN ('in_app', 'email', 'push', 'webhook')
    ),
    
    -- 优先级
    priority VARCHAR(10) DEFAULT 'normal' CHECK (
        priority IN ('low', 'normal', 'high', 'urgent')
    ),
    
    -- 时间戳
    created_at TIMESTAMP DEFAULT NOW(),
    read_at TIMESTAMP,
    sent_at TIMESTAMP,
    expires_at TIMESTAMP
);

CREATE INDEX idx_notifications_recipient_id ON notifications(recipient_id);
CREATE INDEX idx_notifications_recipient_address ON notifications(recipient_address);
CREATE INDEX idx_notifications_type ON notifications(type);
CREATE INDEX idx_notifications_is_read ON notifications(is_read);
CREATE INDEX idx_notifications_is_sent ON notifications(is_sent);
CREATE INDEX idx_notifications_priority ON notifications(priority);
CREATE INDEX idx_notifications_created_at ON notifications(created_at DESC);
CREATE INDEX idx_notifications_expires_at ON notifications(expires_at);
```

#### blockchain_sync_logs (区块链同步日志表)
```sql
CREATE TABLE blockchain_sync_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    
    -- 同步信息
    sync_type VARCHAR(50) NOT NULL CHECK (
        sync_type IN ('user_registration', 'hackathon_creation', 'project_submission', 
                     'score_submission', 'dao_proposal', 'dao_vote', 'nft_mint', 'staking')
    ),
    
    -- 区块链信息
    chain_id INTEGER NOT NULL,
    contract_address VARCHAR(42) NOT NULL,
    tx_hash VARCHAR(66) NOT NULL,
    block_number BIGINT NOT NULL,
    log_index INTEGER,
    
    -- 关联信息
    entity_type VARCHAR(50) NOT NULL,     -- 实体类型
    entity_id UUID,                       -- 数据库中的实体ID
    contract_entity_id BIGINT,            -- 合约中的实体ID
    
    -- 同步状态
    sync_status VARCHAR(20) DEFAULT 'pending' CHECK (
        sync_status IN ('pending', 'processing', 'completed', 'failed')
    ),
    
    -- 数据信息
    event_data JSONB,                     -- 事件数据
    error_message TEXT,                   -- 错误信息
    retry_count INTEGER DEFAULT 0,
    
    -- 时间戳
    block_timestamp TIMESTAMP,
    created_at TIMESTAMP DEFAULT NOW(),
    processed_at TIMESTAMP,
    
    -- 索引
    UNIQUE(tx_hash, log_index)
);

CREATE INDEX idx_blockchain_sync_logs_sync_type ON blockchain_sync_logs(sync_type);
CREATE INDEX idx_blockchain_sync_logs_chain_id ON blockchain_sync_logs(chain_id);
CREATE INDEX idx_blockchain_sync_logs_contract_address ON blockchain_sync_logs(contract_address);
CREATE INDEX idx_blockchain_sync_logs_tx_hash ON blockchain_sync_logs(tx_hash);
CREATE INDEX idx_blockchain_sync_logs_block_number ON blockchain_sync_logs(block_number);
CREATE INDEX idx_blockchain_sync_logs_entity_type ON blockchain_sync_logs(entity_type);
CREATE INDEX idx_blockchain_sync_logs_sync_status ON blockchain_sync_logs(sync_status);
CREATE INDEX idx_blockchain_sync_logs_created_at ON blockchain_sync_logs(created_at DESC);
```

#### ipfs_metadata (IPFS元数据缓存表)
```sql
CREATE TABLE ipfs_metadata (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    
    -- IPFS信息
    ipfs_hash TEXT NOT NULL UNIQUE,
    content_type VARCHAR(100),
    content_size BIGINT,
    
    -- 内容分类
    category VARCHAR(50) NOT NULL CHECK (
        category IN ('user_profile', 'hackathon_data', 'project_data', 'nft_metadata', 'document')
    ),
    
    -- 关联信息
    entity_type VARCHAR(50),
    entity_id UUID,
    
    -- 缓存内容
    cached_content JSONB,                 -- 缓存的JSON内容
    content_preview TEXT,                 -- 内容预览
    
    -- 验证信息
    is_verified BOOLEAN DEFAULT FALSE,
    verification_method VARCHAR(50),      -- 验证方法
    checksum VARCHAR(128),                -- 内容校验和
    
    -- 访问统计
    access_count INTEGER DEFAULT 0,
    last_accessed_at TIMESTAMP,
    
    -- 状态
    status VARCHAR(20) DEFAULT 'available' CHECK (
        status IN ('available', 'unavailable', 'corrupted', 'deleted')
    ),
    
    -- 时间戳
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_ipfs_metadata_ipfs_hash ON ipfs_metadata(ipfs_hash);
CREATE INDEX idx_ipfs_metadata_category ON ipfs_metadata(category);
CREATE INDEX idx_ipfs_metadata_entity_type ON ipfs_metadata(entity_type);
CREATE INDEX idx_ipfs_metadata_entity_id ON ipfs_metadata(entity_id);
CREATE INDEX idx_ipfs_metadata_status ON ipfs_metadata(status);
CREATE INDEX idx_ipfs_metadata_last_accessed_at ON ipfs_metadata(last_accessed_at);

CREATE TRIGGER update_ipfs_metadata_updated_at 
    BEFORE UPDATE ON ipfs_metadata 
    FOR EACH ROW 
    EXECUTE FUNCTION update_updated_at_column();
```

## 数据关系图

```
┌─────────────────────────────────────────────────────────────┐
│                    HackX 数据关系图                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│     ┌─────────────┐    ┌─────────────┐    ┌─────────────┐  │
│     │    users    │    │ hackathons  │    │  projects   │  │
│     │             │    │             │    │             │  │
│     │ id (PK)     │◄──┐│ id (PK)     │◄──┐│ id (PK)     │  │
│     │ wallet_addr │   ││ organizer_id│   ││ hackathon_id│  │
│     │ ipfs_hash   │   │└─────────────┘   │└─────────────┘  │
│     └─────────────┘   │                  │                 │
│            │          │                  │                 │
│            │          │                  │                 │
│     ┌─────────────┐   │ ┌─────────────┐  │ ┌─────────────┐ │
│     │user_skills  │   │ │hackathon_   │  │ │project_     │ │
│     │             │   │ │participants │  │ │scores       │ │
│     │ user_id(FK) │◄──┘ │             │  │ │             │ │
│     └─────────────┘     │ user_id(FK) │◄─┘ │ project_id  │ │
│                         │hackathon_id │    │ judge_id    │ │
│                         └─────────────┘    └─────────────┘ │
│                                                             │
│     ┌─────────────┐    ┌─────────────┐    ┌─────────────┐  │
│     │   teams     │    │dao_proposals│    │nft_certif.. │  │
│     │             │    │             │    │             │  │
│     │ id (PK)     │    │ id (PK)     │    │ id (PK)     │  │
│     │ leader_id   │◄───┤ proposer_id │    │ user_id     │◄─┤
│     │hackathon_id │    │             │    │hackathon_id │  │
│     └─────────────┘    └─────────────┘    │ project_id  │  │
│            │                   │          └─────────────┘  │
│            │                   │                           │
│     ┌─────────────┐    ┌─────────────┐    ┌─────────────┐  │
│     │team_members │    │ dao_votes   │    │staking_     │  │
│     │             │    │             │    │records      │  │
│     │ team_id(FK) │◄───┘│proposal_id  │◄───┤ user_id     │  │
│     │ user_id(FK) │     │ voter_id    │    │             │  │
│     └─────────────┘     └─────────────┘    └─────────────┘  │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 索引策略

### 1. 主键索引 (自动创建)
- 所有表的主键自动创建B-tree索引
- UUID类型主键，支持高并发插入

### 2. 外键索引
```sql
-- 用户相关外键索引
CREATE INDEX idx_user_skills_user_id ON user_skills(user_id);
CREATE INDEX idx_user_social_links_user_id ON user_social_links(user_id);
CREATE INDEX idx_hackathon_participants_user_id ON hackathon_participants(user_id);

-- 黑客松相关外键索引
CREATE INDEX idx_hackathons_organizer_id ON hackathons(organizer_id);
CREATE INDEX idx_hackathon_participants_hackathon_id ON hackathon_participants(hackathon_id);
CREATE INDEX idx_projects_hackathon_id ON projects(hackathon_id);

-- 项目相关外键索引
CREATE INDEX idx_project_scores_project_id ON project_scores(project_id);
CREATE INDEX idx_project_likes_project_id ON project_likes(project_id);
```

### 3. 业务查询索引
```sql
-- 搜索相关复合索引
CREATE INDEX idx_hackathons_status_start_date ON hackathons(status, start_date);
CREATE INDEX idx_projects_status_score ON projects(status, average_score DESC);
CREATE INDEX idx_dao_proposals_status_end_time ON dao_proposals(status, voting_end_time);

-- Web3相关索引
CREATE INDEX idx_users_wallet_chain ON users(wallet_address, chain_id);
CREATE INDEX idx_blockchain_sync_logs_chain_contract ON blockchain_sync_logs(chain_id, contract_address);
CREATE INDEX idx_nft_certificates_owner_type ON nft_certificates(owner_address, certificate_type);
```

### 4. 全文搜索索引
```sql
-- PostgreSQL全文搜索索引
CREATE INDEX idx_hackathons_fulltext ON hackathons USING gin(
    to_tsvector('english', title || ' ' || COALESCE(description, ''))
);

CREATE INDEX idx_projects_fulltext ON projects USING gin(
    to_tsvector('english', name || ' ' || COALESCE(description, ''))
);

CREATE INDEX idx_users_fulltext ON users USING gin(
    to_tsvector('english', username || ' ' || COALESCE(bio, ''))
);
```

### 5. 部分索引
```sql
-- 只对活跃数据建索引
CREATE INDEX idx_users_active_wallet ON users(wallet_address) 
WHERE is_active = true;

CREATE INDEX idx_hackathons_public_featured ON hackathons(is_featured, start_date) 
WHERE is_public = true AND status != 'cancelled';

CREATE INDEX idx_projects_submitted ON projects(submitted_at, average_score DESC) 
WHERE status IN ('submitted', 'under_review', 'reviewed');
```

## 缓存策略

### 1. Redis缓存架构
```
┌─────────────────────────────────────────────────────────────┐
│                     Redis 缓存层次                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  L1: 热点数据缓存 (TTL: 5分钟)                              │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ • 活跃黑客松列表                                    │   │
│  │ • 用户会话数据                                      │   │
│  │ • 实时统计数据                                      │   │
│  │ • 区块链网络状态                                    │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  L2: 常用数据缓存 (TTL: 30分钟)                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ • 用户资料信息                                      │   │
│  │ • 黑客松详情                                        │   │
│  │ • 项目详情                                          │   │
│  │ • IPFS元数据                                        │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  L3: 静态数据缓存 (TTL: 4小时)                              │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ • 技能标签列表                                      │   │
│  │ • 国家/城市列表                                     │   │
│  │ • 配置信息                                          │   │
│  │ • 智能合约ABI                                       │   │
│  └─────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
```

### 2. 缓存键命名规范
```
# 用户相关
user:profile:{user_id}
user:skills:{user_id}
user:hackathons:{user_id}

# 黑客松相关
hackathon:list:{status}:{page}
hackathon:detail:{hackathon_id}
hackathon:participants:{hackathon_id}

# 项目相关
project:list:{hackathon_id}:{page}
project:detail:{project_id}
project:scores:{project_id}

# 统计数据
stats:hackathons:count
stats:users:count
stats:projects:count

# Web3相关
web3:contract:{chain_id}:{address}
web3:tx:{tx_hash}
ipfs:metadata:{ipfs_hash}
```

### 3. 缓存更新策略
```sql
-- 缓存失效触发器示例
CREATE OR REPLACE FUNCTION invalidate_cache()
RETURNS TRIGGER AS $$
BEGIN
    -- 发送缓存失效信号到Redis
    PERFORM pg_notify('cache_invalidate', json_build_object(
        'table', TG_TABLE_NAME,
        'operation', TG_OP,
        'id', COALESCE(NEW.id, OLD.id)
    )::text);
    
    RETURN COALESCE(NEW, OLD);
END;
$$ language 'plpgsql';

-- 应用到关键表
CREATE TRIGGER cache_invalidate_users
    AFTER INSERT OR UPDATE OR DELETE ON users
    FOR EACH ROW
    EXECUTE FUNCTION invalidate_cache();

CREATE TRIGGER cache_invalidate_hackathons
    AFTER INSERT OR UPDATE OR DELETE ON hackathons
    FOR EACH ROW
    EXECUTE FUNCTION invalidate_cache();
```

## 数据同步机制

### 1. 区块链事件监听
```typescript
// 事件监听服务示例
class BlockchainSyncService {
    private async processHackathonCreated(event: HackathonCreatedEvent) {
        try {
            // 1. 解析区块链事件
            const { hackathonId, organizer, dataCID } = event.args;
            
            // 2. 从IPFS获取详细数据
            const hackathonData = await this.ipfsService.getJSON(dataCID);
            
            // 3. 更新数据库
            await this.database.hackathons.upsert({
                where: { contract_id: hackathonId },
                update: {
                    sync_status: 'completed',
                    tx_hash: event.transactionHash,
                    block_number: event.blockNumber,
                },
                create: {
                    contract_id: hackathonId,
                    organizer_address: organizer,
                    ipfs_hash: dataCID,
                    ...hackathonData,
                    sync_status: 'completed',
                    tx_hash: event.transactionHash,
                    block_number: event.blockNumber,
                }
            });
            
            // 4. 记录同步日志
            await this.logSync({
                sync_type: 'hackathon_creation',
                tx_hash: event.transactionHash,
                block_number: event.blockNumber,
                entity_id: hackathonId,
                sync_status: 'completed'
            });
            
            // 5. 清除相关缓存
            await this.cacheService.invalidate(`hackathon:*`);
            
        } catch (error) {
            await this.logSync({
                sync_type: 'hackathon_creation',
                tx_hash: event.transactionHash,
                sync_status: 'failed',
                error_message: error.message
            });
        }
    }
}
```

### 2. 数据一致性检查
```sql
-- 定期数据一致性检查存储过程
CREATE OR REPLACE FUNCTION check_data_consistency()
RETURNS TABLE(
    table_name TEXT,
    issue_type TEXT,
    entity_id UUID,
    description TEXT
) AS $$
BEGIN
    -- 检查黑客松数据一致性
    RETURN QUERY
    SELECT 
        'hackathons'::TEXT,
        'missing_ipfs_data'::TEXT,
        h.id,
        'Hackathon has contract_id but missing IPFS hash'::TEXT
    FROM hackathons h
    WHERE h.contract_id IS NOT NULL 
      AND h.ipfs_hash IS NULL;
    
    -- 检查项目数据一致性
    RETURN QUERY
    SELECT 
        'projects'::TEXT,
        'sync_status_mismatch'::TEXT,
        p.id,
        'Project sync status is pending for more than 1 hour'::TEXT
    FROM projects p
    WHERE p.sync_status = 'pending'
      AND p.created_at < NOW() - INTERVAL '1 hour';
    
    -- 检查用户数据一致性
    RETURN QUERY
    SELECT 
        'users'::TEXT,
        'wallet_verification_missing'::TEXT,
        u.id,
        'User has wallet address but not verified'::TEXT
    FROM users u
    WHERE u.wallet_address IS NOT NULL
      AND u.wallet_verified = false
      AND u.created_at < NOW() - INTERVAL '24 hours';
END;
$$ LANGUAGE plpgsql;
```

### 3. 故障恢复机制
```sql
-- 数据修复存储过程
CREATE OR REPLACE FUNCTION repair_sync_issues()
RETURNS INTEGER AS $$
DECLARE
    repaired_count INTEGER := 0;
BEGIN
    -- 重置长时间处于pending状态的记录
    UPDATE hackathons 
    SET sync_status = 'failed'
    WHERE sync_status = 'pending'
      AND created_at < NOW() - INTERVAL '2 hours';
    
    GET DIAGNOSTICS repaired_count = ROW_COUNT;
    
    -- 重新同步failed状态的记录（如果重试次数未超限）
    UPDATE blockchain_sync_logs
    SET sync_status = 'pending', retry_count = retry_count + 1
    WHERE sync_status = 'failed'
      AND retry_count < 3
      AND created_at > NOW() - INTERVAL '24 hours';
    
    RETURN repaired_count;
END;
$$ LANGUAGE plpgsql;
```

## 性能优化建议

### 1. 查询优化
```sql
-- 分页查询优化示例
-- BAD: OFFSET性能差
SELECT * FROM hackathons ORDER BY created_at DESC LIMIT 20 OFFSET 1000;

-- GOOD: 基于游标的分页
SELECT * FROM hackathons 
WHERE created_at < '2024-01-01 00:00:00'
ORDER BY created_at DESC 
LIMIT 20;

-- 复合查询优化
-- BAD: 多个单独查询
SELECT h.*, 
       (SELECT COUNT(*) FROM hackathon_participants hp WHERE hp.hackathon_id = h.id) as participant_count,
       (SELECT COUNT(*) FROM projects p WHERE p.hackathon_id = h.id) as project_count
FROM hackathons h;

-- GOOD: JOIN查询
SELECT h.*, 
       COALESCE(hp.participant_count, 0) as participant_count,
       COALESCE(p.project_count, 0) as project_count
FROM hackathons h
LEFT JOIN (
    SELECT hackathon_id, COUNT(*) as participant_count
    FROM hackathon_participants
    GROUP BY hackathon_id
) hp ON h.id = hp.hackathon_id
LEFT JOIN (
    SELECT hackathon_id, COUNT(*) as project_count
    FROM projects
    GROUP BY hackathon_id
) p ON h.id = p.hackathon_id;
```

### 2. 连接池配置
```sql
-- PostgreSQL连接池配置建议
-- max_connections = 200
-- shared_buffers = 1GB (25% of RAM)
-- effective_cache_size = 3GB (75% of RAM)
-- work_mem = 16MB
-- maintenance_work_mem = 256MB
-- checkpoint_completion_target = 0.9
-- wal_buffers = 32MB
-- default_statistics_target = 100
```

### 3. 分区策略
```sql
-- 大表分区示例（按时间分区）
CREATE TABLE notifications_2024_01 PARTITION OF notifications
    FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');

CREATE TABLE notifications_2024_02 PARTITION OF notifications
    FOR VALUES FROM ('2024-02-01') TO ('2024-03-01');

-- 按哈希分区示例
CREATE TABLE blockchain_sync_logs_part_0 PARTITION OF blockchain_sync_logs
    FOR VALUES WITH (MODULUS 4, REMAINDER 0);
```

## 监控和维护

### 1. 性能监控查询
```sql
-- 慢查询监控
SELECT query, mean_time, calls, total_time, stddev_time
FROM pg_stat_statements
WHERE mean_time > 1000  -- 平均执行时间超过1秒
ORDER BY mean_time DESC
LIMIT 10;

-- 索引使用率监控
SELECT 
    schemaname,
    tablename,
    indexname,
    idx_tup_read,
    idx_tup_fetch,
    idx_scan
FROM pg_stat_user_indexes
WHERE idx_scan = 0  -- 未使用的索引
ORDER BY schemaname, tablename;

-- 表大小监控
SELECT 
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) as size
FROM pg_tables
WHERE schemaname = 'public'
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC;
```

### 2. 数据完整性检查
```sql
-- 定期数据完整性检查任务
DO $$ 
BEGIN
    -- 检查外键约束
    PERFORM 1 FROM information_schema.constraint_column_usage
    WHERE constraint_name LIKE '%_fkey';
    
    -- 检查数据范围约束
    PERFORM 1 FROM project_scores WHERE overall_score < 1 OR overall_score > 5;
    
    -- 检查时间逻辑约束
    PERFORM 1 FROM hackathons WHERE start_date >= end_date;
    
    IF FOUND THEN
        RAISE EXCEPTION 'Data integrity check failed';
    END IF;
END $$;
```

### 3. 备份策略
```bash
#!/bin/bash
# 数据库备份脚本

# 全量备份（每周）
pg_dump -h localhost -U hackx_user -d hackx_db \
    --format=custom \
    --compress=9 \
    --file=/backup/hackx_full_$(date +%Y%m%d).backup

# 增量备份（每日）
pg_dump -h localhost -U hackx_user -d hackx_db \
    --format=custom \
    --compress=9 \
    --data-only \
    --file=/backup/hackx_incremental_$(date +%Y%m%d).backup

# WAL归档
archive_command = 'cp %p /backup/wal_archive/%f'
```

这个数据库设计文档提供了HackX平台完整的数据库架构，充分考虑了Web3特性、性能优化、数据一致性和可维护性。所有设计都围绕着混合存储架构，确保数据的去中心化特性同时保持查询性能。
